
#### Статья

[Статья про chroot](https://dzen.ru/a/Z_dm7MnG4gBnww0l)


#### Оболочка Linux

**Оболочка Linux** - это программа, которая предоставляет интерфейс для взаимодействия пользователя с ОС. Она позволяет выполнять команды, запускать программы, а также управлять файлами и процессами.

**Функции оболочки**:
- **Командный интерпретатор**: Оболочка принимает команды от пользователя, интерпретирует их в машинный код и выполняет
- **Скриптование**: Позволяют писать скрипты - последовательности команд, которые могут автоматизировать задачи
- **Управление процессами**: Позволяют запускать, останавливать и управлять процессами
- **Перенаправление ввода/вывода**: Позволяют перенаправлять ввод и вывод команд, что упрощает работу с данными

**Существующие оболочки**:
- **Bash**: Наиболее распространенная оболочка в Linux. Поддерживает сценарии и расширенные функции
- **Zsh**: Оболочка, которая предлагает дополнительные функции по сравнению с Bash, такие как автозаполнение и улучшенные возможности настройки.
- **Fish**: Оболочка, ориентированная на удобство использования, с интуитивно понятным синтаксисом и автоматически подсвечиваемым синтаксисом.
- **Tcsh**: Расширенная версия C Shell (csh), с поддержкой автозаполнения и других функций.
- **Dash**: Легковесная оболочка, часто используемая для выполнения сценариев
#### Файловая система и  Добавление нового Диска в систему

**Файловая система** - 


В Linux существует следующие типы файловых систем

| **Файловая система** | **Журналирование** | **Максимальный размер файла** | **Максимальный размер раздела** | **Поддержка** | **Особенности**                                                            |
| -------------------- | ------------------ | ----------------------------- | ------------------------------- | ------------- | -------------------------------------------------------------------------- |
| **ext2**             | Нет                | 2 ТБ                          | 2 ТБ                            | Широко        | Простая, но устарела.                                                      |
| **ext3**             | Да                 | 2 ТБ                          | 2 ТБ                            | Широко        | Расширение ext2 с журналированием.                                         |
| **ext4**             | Да                 | 16 ТБ                         | 1 ЭБ                            | Широко        | Поддерживает большие объемы, улучшенная производительность.                |
| **XFS**              | Да                 | 8 ЭБ                          | 8 ЭБ                            | Широко        | Высокая производительность, оптимизирована для больших файлов.             |
| **Btrfs**            | Да                 | 16 ЭБ                         | 16 ЭБ                           | Активно       | Поддержка снимков, динамического управления объемом, проверки целостности. |
| **ReiserFS**         | Да                 | 8 ТБ                          | 8 ТБ                            | Умеренно      | Высокая производительность для небольших файлов.                           |
| **JFS**              | Да                 | 4 ТБ                          | 4 ТБ                            | Умеренно      | Оптимизирована для больших объемов данных.                                 |
| **FAT32**            | Нет                | 4 ГБ                          | 8 ТБ                            | Широко        | Совместимость с Windows, простота использования.                           |
| **NTFS**             | Да                 | 16 ТБ                         | 16 ТБ                           | Широко        | Поддержка расширенных атрибутов, используется в Windows.                   |
| **vfat**             | Нет                | 4 ГБ                          | 8 ТБ                            | Широко        | Поддержка длинных имен файлов.                                             |
| **ISO 9660**         | Нет                | 2 ГБ                          | 2 ГБ                            | Широко        | Для CD-ROM, поддерживает Rock Ridge и Joliet.                              |
| **SquashFS**         | Нет                | Ограничен размером образа     | Ограничен размером образа       | Умеренно      | Сжатая файловая система для Live CD                                        |

Для работы с дисками есть утилиты **fdisk cfdisk**. 
С помощью этой команды мы можем список всех устройств, и их разделы.
```bash
sudo fdisk -l
```

Командой **lsblk** можно посмотреть список блочных элементов в системе
```bash
sudo lsblk
```

##### Пример добавления диска

У нас есть новый жесткий диск - hdd2. Нам нужно добавить его к нашему ОС. 
1. Командной **lsblk** проверяем виден ли диск **hdd2** в нашей системе
   ```bash
   sudo lsblk
```
2. После того, как убедились, что диск виден в системе теперь надо создать раздел. Для этого можно воспользоваться **fdisk или cfdisk**
   
**fdisk**
   ```bash
   sudo fdisk /dev/<disk-name>
   
   sudo fdisk /dev/sdc
   Далее надо выбрать n, и выставить нужные настройки 
   И полсе этого нужно сохранить его командой w
   sudo lsblk #Смотрим создался ли раздел
  ```
  **cfdisk**
  ```bash
  sudo cfdisk /dev/disk-name
  
  sudo cfdisk /dev/sdc
  Выбераем type dos. Нажимаем New -> Указываем объем раздела -> выбираем тип раздела (primary/extended) -> Нажимаем Write -> Пишем yes, чтобы сохранить -> После этого нажимаем q, и выходим с cfdisk
 ```
 
 3. Далее смотрим создался раздел нашего диска. Должен отобразиться раздел **/dev/sdc1**
    ```bash
    sudo lsblk
   ```

4. Нужно создать файловую систему для раздела, и смонтировать в каталог Заходим в **/etc/fstab** , чтобы прописать это.
   ```bash
   /dev/sdc1 /media/hdd2 default ntfs 0 0
Раздел Диска, точка-монтирования, default, ntfs-тип файловой системы, 0-выключено рез.копирование, 0-выключена проверка файловой системы
``` 

5. Перезагружаем наш сервер.
6. После перезагрузки проверяем сохранился ли наш смонтированный раздел
   ```bash
   sudo cd /media/hdd2
```

#### Изменение имена ПК и IP-адреса
##### Изменение имени ПК

Для того чтобы поменять имя ПК требуется требуется внести изменения в двух файлах 
**/etc/hostname /etc/hosts** . После изменения файлов требуется перезагрузить ПК
```bash
sudo nano /etc/hostname
sudo nano /etc/hosts
```

##### Изменение Ip-адреса

Для настройки сети в Linux существуют следующие утилиты: 

###### ifconfig
 Просмотр информации о интерфейсах
 ```bash
 sudo ifconfig
```

Включение интерфейса
```bash
sudo ifconfig eth0 up
```

Отключение интерфейса
```bash
sudo ifconfig eth0 down
```

Установка статического IP-адреса
```bash
sudo ifconfig eth0 192.168.1.100 netmask 255.255.255.0
```

Изменение MAC-адреса интерфейса
```bash
sudo ifconfig eth0 hw ether 00:11:22:33:44:55
```

Добавить дополнительный Ip-адрес сетевому интерфейсу `
```bash
sudo ifconfig eth0:0 192.168.1.101 netmask 255.255.255.0
```

###### netplan

Для конфигурации сети через **netplan** требуется перейти в каталог **/etc/netplan**, и создать в нём файл, с расширением `.yaml`. 
Задание статического IP-адреса сетевому интерфейсу
```yaml
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: no
      addresses:
        - 192.168.1.101/24
      routes:
      - to: 0.0.0.0/0
        via: 192.168.1.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
```

Задание динамического IP-адреса
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      dhcp4: yes
```

###### NetworkManager

Установка NetworkManager
```bash
sudo apt install -y network-manager
```

Запуск службы NetworkManager
```bash
sudo systemctl start NetworkManager
```

Просмотреть состояние сетевых интерфейсов
```bash
sudo nmcli device status
```

Соединение по DHCP Ip-адресу
 ```bash
 sudo nmcli connection add con-name "dhcp" type ethernet ifname enp0s3
```

Соединение по статическому Ip-адресу
```bash
sudo nmcli connection add con-name "static" ifname enp2s0 autoconnect no type ethernet ip4 192.168.0.210 gw4 192.168.0.1
```
#### Планировщик Crontab

**Crontab** - это планировщик задач, который позволяет планировать выполнение команд или скриптов в определённое время или с заданным интервалом. С помощью него можно автоматизировать следующие задачи: резервное копирование, обновление систем отправка отчётов и многое другое

Основные понятия:
- **Cron**: фоновый процесс, который управляет задачами, запланированными в `crontab`
- **Задача**: команда или скрипт, который будет выполняться
- **Планировщик**: файл, в котором хранятся задания, которые нужно выполнить
Существует два файла для настройки cron:
1. **crontab -e** - команда используется для редактирования файла `crontab` для текущего пользователя. Задачи, добавляемые с помощью этой команды будут выполняться от имени пользователя, который их создал. 
   Формат записи в файле следующий.
   ```bash
         *       *     *    *         *        команда
       минута  часы  день месяц  день недели
   ```
   
     ```bash
     0 2 * * * /path/script.sh
      ```
   
2. **/etc/crontab** - это системный файл `crontab`, который используется для задания задач, выполняемых от имени различных пользователей. В этом файле, могут быть указаны, которые будут выполняться от имени любого пользователя, и для этого указывается имя пользователя.
   Формат записи в файле следующий
   ```bash
            *      *     *       *        *            *            *
          минута  часы  день   месяц  день недели  пользователь  команда
    ```

    ```bash
    0 2 * * * user-name /path/script.sh
    ```

#### Работы с SSH-ключом

**Ssh-ключ** - это пара криптографических ключей, которая используется для безопасного шифрования данных и аутентификации при установке ssh-соединения. Пара состоит из:
1. **Открытого (публичного) ключа**: Используется для шифрования данных при обращении к серверу. Открытый ключ - лишь замок на двери, за которой находится важна информация. Без второго SSH-ключа он не имеет смысла
2. **Закрытого (приватного) ключа**: Он является ключом к замку. Он расшифровывает данные. С ним нужно быть в разы осторожнее: хранить, соблюдая правила безопасности, и не передавать вторым лицам. При генерации SSH-ключа закрытый ключ нужно запаролить, чтобы обеспечить дополнительную защиту. 
![[Pasted image 20250623124107.png]]

**Типы SSH-ключей**:
- **Ed25519** (рекомендуется) - быстрый и безопасный
- **RSA** (устаревший, но поддерживается везде) - требует длины ≥4096 бит.
- **ECDSA** - менее популярен из--за потенциальных уязвимостей

##### Формирование открытого и закрытого ключа ssh
1. На ПК с которого хотим подключиться к удаленному ПК, открываем терминал и выполняем команду `ssh-keygen`.
2. Сформируется два ключа `id_rsa`- закрытый, и `id_rsa.pub`публичный`
3. Копируем публичный ключ `id_rsa_pub` на удалённый сервер.
    ```bash
 ssh-copy-id username@host_ip
 ```
С помощью этой команды происходит копирование. Скопированный файл автоматически попадает в директорию `~/.ssh/`, и там создаётся файл `authorized_keys`. Это для Linux

В случае с Windows в директории `C:\Users\Username\.ssh` создаём файл `authorized_keys`, и в него записываем наш публичный ключ - `id_rsa.pub`

4. Если требуется отключить авторизацию по паролю при входе по ssh, то надо изменить конфигурационный файл `/etc/ssh/sshd_config`. Там находим строку `PasswordAuthentication`, и ставим параметр `no`.
5. Далее перезагружаем службу `ssh`, и пробуем подключиться
    ```bash
 sudo systemctl restart ssh
   ```

#### Ядро Linux

**Ядро Linux** - это главный компонент ОС, отвечающая за управление аппаратными ресурсами и взаимодействие между программами и оборудованием. Основные функции и задачи ядра:
	-**Управление процессами**: создаёт, планирует и завершает выполнение процессов
	-**Управление памятью**: отвечает за распределение ОЗУ между процессами, а также за виртуальную память и защиту
	- **Управление устройствами**: ядро взаимодействует с аппаратным обеспечением (дисками, сетевыми картами и тд) через драйверы.
	- **Файловая система**: обеспечивает доступ к фс, позволяя пользователям и приложениям читать и записывать данные
	- **Системные вызовы**: предоставляет интерфейсы для взаимодействия приложений с аппаратными ресурсами через системные вызовы.
	- **Безопасность управления доступом**: реализует механизмы управления правами доступа к ресурсам.
#### Chroot

**Chroot** - это системная утилита Unix, которая используется для смены текущего корневого каталога для создания нового окружения, логически отдельного от основной системы.
Команда **chroot** позволяет запустить командную оболочку будто бы корневая директория системы (/) - это не текущий раздел, а специально подготовленная папка, куда смонтируется фс неисправного ПК.

Chroot спасает в следующих случаях:
- **Повреждено ядро Linux**: Например сбой в процессе обновления или некорректной установке драйверов
- **Сломанные пакеты**: Когда из-за сбоя сети или прерванной установки пакеты повреждены или имеют неверные зависимости.
- **Ошибки конфигурации GRUB:** загрузчик системы не запускается, и система виснет на старте.
- **Повреждение файловой системы:** некорректное отключение питания или аппаратный сбой HDD/SSD может привести к невозможности нормальной загрузки.

#### Namespaces, cgroups

**Namespaces** отвечает за изоляцию процессов от других процессов и ресурсов. Он создаёт виртуальное окружение для каждого процесса, в котором он работает, что позволяет избежать конфликтов между процессами и обеспечить безопасность данных. Они могут быть использованы для изоляции файловой системы, сети, процессов и других ресурсов.

Основные типы:
- **PID** - изоляция дерева процессов (процессы в namespace видят только "свои" PID).
- **Network** -  отдельная сетевая стека (свои интерфейсы, IP-адреса).
- **Mount(mnt)** - изолированное монтирование файловых систем.
- **UTS** -  уникальное имя хоста и домена для контейнера.
- **User** - изоляция UID/GID (пользователи внутри namespace не видят внешних).
- **IPC** - изоляция меж-процессного взаимодействия (очереди, shared memory).
**Пример**: Docker-контейнер видит только свои процессы, не может видеть процессы хоста. 

**Cgroups** позволяет ограничивать и распределять ресурсы (CPU, RAM disk space) между группами процессов. Возможности cgroups:
- **Ограничение ресурсов**: Например, выделение 20% CPU или 1 ГБ RAM для контейнера
- **Приоритезация**: Задание весов (например, `cpu.shares`) для распределения CPU между группами.
- **Учёт потребления**: Мониторинг использования памяти, сетевого трафика
- **Управление устройствами:** Разрешение/запрет доступа к устройствам (например, `/dev/sda`).
**Пример**: K8S использует cgroups для изоляции ресурсов контейнеров

Cgroups позволяют управлять доступом к ресурсам для определенных групп процессов, а namespaces - обеспечивают изоляцию между этими процессами. Получается, что  cgroups определяют какие ресурсы могут быть использованы, а namespaces обеспечивают безопасное окружение для их использования. Совместное их использование позволяет обеспечить эффективное управление ресурсами и безопасность работы системы Linux.
#### Последовательность загрузки Linux

1. **Включение питания**:
2. **Запуск BIOS/UEFI**: BIOS/UEFI выполняет самотестирование, и инициализирует оборудование. Далее ищет загрузочное устройство (HDD, SSD, USB) в порядке указанном в настройках
3. **Загрузка загрузчика GRUB**: GRUB отображает меню выбора ядра. Загружает выбранное ядро и **initramfs**(временную корневую файловую систему).
4. **Загрузка ядра**: Ядро инициализирует оборудование (процессор, память, диски). Монтирует корневую файловую систему (`/`), указанной в параметрах загрузки
5. **Запуск процесса init (Systemd, SysVinit, OpenRC)**: Init читает следующие настройки:
	   - Читает настройки загрузки, в случае systemd(/etc/systemd/system/default.target)
	   -  Запускает системные сервисы (сетевые службы, демон udevd для работы с устройствами и т. д.);
	   -  Активирует многопользовательский режим и запускает ключевые службы, обеспечивающие функционирование системы.
6. **Монтирование файловых систем**: Читается файл `/etc/fstab` для монтирования всех разделов (например, `/home`, `/var`)
7. **Запуск сервисов и графической оболочки**: Активация сетевых служб, демонов (`sshd`, `cron`). Если настроен графический режим: запуск дисплейного менеджера (GDM, LightDM), затем DE (GNOME, KDE и тд)

#### Процесс, служба, сервис

##### Процесс

**Процесс** - это экземпляр программы или скрипта, который выполняется в ОС. Каждому процессу присваивается уникальный идентификатор **PID**
**Пример**: Когда открываем текстовый редактор, система создаёт процесс, который управляет его выполнением

##### Служба

**Служба** -  это специальный процесс, который работает в фоновом режиме и предоставляет определенные функции или услуги другим процессам или пользователям.

Пример: Nginx, Apache

##### Сервис

**Сервис** - 

**Команды для работы с процессами**:
#### Zombie-процесс

**Zombie-процесс** - это дочерний процесс, который закончил своё выполнение, но всё ещё присутствует в списке процессов ОС. Он отображается в списке процессов с состоянием `z`.

**Причины возникновения**:
- **Ошибки программирования**:  Если родительский процесс не быстро собирает статус завершения дочернего процесса, это может привести к созданию зомби.
- **Зависание родительского процесса**: Например, если родитель занят или не реагирует на сигналы, он может вовремя не забрать код завершения
- **Завершение родительского процесса**: Если родительский процесс заканчивается до сбора статусов завершения дочерних процессов, дочерние процессы становятся потомками процесса init (PID 1), который предотвращает их превращение в зомби
#### Inode
#### Iptables
#### LXC, LXD, LXCFS

**LXC (Linux Containers)** - 